/* KNOWN BUGS:
 * - When SOUND is defined, the first few (6?) rolls after power-up will always yield "1",
 * seemingly due to a conflict between the Tone library and the Entropy library.
 * You can flush theses values by rolling the di(c)e a couple times,
 * if your BOUNCE value does not take care of it already. Or, undefine SOUND.
 */

#undef SOUND
/* I suspected that the Tone library was incompatible with the Entropy library,
 * so I made it easy to switch it on and off.
 * Comment out the next line (#define SOUND) to get rid of the Tone library.
 */
#define SOUND

#ifdef SOUND
#include <Tone.h>
#endif
#include "EEPROM_UTILS.h"
#include "LCD_ERC1602_4.h"
#include <Keypad.h>
#include <Entropy.h>

/* Notes about the board:
 *  
 * On the Adafruit Pro Trinket, pins 2 and 7 are not available.
 * They are used for the dedicated USB bootloading setup.
 * 
 * A6 and A7 are analog input only pins and cannot be used for LEDs, buttons, servos, etc.
 * They are only for analogRead() usage.
 * 
 * There is no Serial-to-USB chip onboard (i.e. no console through USB).
 * You can use any FTDI cable to connect to the FTDI port for a Serial connection.
 */

/* Note: the following values of bouncesDuration and nbBounces will be overwritten unless the EEPROM does not hold valid values */
uint16_t bouncesDuration = 2000; // how long dice bounce (regardless of how many times they bounce), in milliseconds
uint8_t nbBounces = 3; // number of bounces for each die (see below for min and max values)

#define MIN_BOUNCES_DURATION 100 // in milliseconds
#define MAX_BOUNCES_DURATION 5000 // in milliseconds
#define MIN_NB_BOUNCES 1
#define MAX_NB_BOUNCES 9
#define DURATION_ADDR 0
#define BOUNCES_ADDR 2
#define INPUT_POS 10
uint8_t caretOffset = 0;
uint8_t nbDice = 0;
uint16_t nbSides = 0;
uint8_t nbSidesInput[3];
uint8_t nbSidesInputLen = 0;

LCD_ERC1602_4 lcd;

const uint8_t PAD_ROWS = 4;
const uint8_t PAD_COLS = 4;
const char KEY_PAD[PAD_ROWS][PAD_COLS] = {
  {'1', '2', '3', 'A'},
  {'4', '5', '6', 'B'},
  {'7', '8', '9', 'C'},
  {'*', '0', '#', 'D'}
};
uint8_t rowPins[PAD_ROWS] = {A0, A1, A2, A3};
uint8_t colPins[PAD_COLS] = {6, 5, 4, 3};
Keypad customKeypad = Keypad(makeKeymap(KEY_PAD), rowPins, colPins, PAD_ROWS, PAD_COLS);

bool muted = false;
#ifdef SOUND
const uint8_t HI_FREQ_PIN = 8;
const uint8_t LO_FREQ_PIN = 0;
const uint16_t COL_FREQS[] = {1209, 1336, 1477, 1633};
const uint16_t ROW_FREQS[] = {697, 770, 852, 941};
const uint16_t BEEP_MILLIS = 200;
Tone dualTone[2];
#endif

// number of runs for the test
#define NB_RUNS_TEST 2000
// number of sides for the test runs
#define NB_SIDES_TEST 4
uint16_t count[NB_SIDES_TEST];

void setup() {
  lcd.begin();
  showInputMenu();
  
  #ifdef SOUND
  dualTone[0].begin(HI_FREQ_PIN);
  dualTone[1].begin(LO_FREQ_PIN);
  #endif
  
  /* This is how Arduino recommends generating pseudo-random numbers: randomSeed(analogRead(0));
   *  
   * "If it is important for a sequence of values generated by random() to differ, on subsequent
   * executions of a sketch, use randomSeed() to initialize the random number generator
   * with a fairly random input, such as analogRead() on an unconnected pin."
   * (source: https://www.arduino.cc/reference/en/language/functions/random-numbers/randomseed/)
   * 
   * But!
   * 
   * "While it is common practice to seed the internal random generator this way, it doesn't really do a very good job.
   * In practice, the analogRead(0) on an unconnected pin doesn't produce too many possible values,
   * and even theoretically will only produce up to 10 bit (in practice much less),
   * when the seed function is designed to use a 32-bit integer."
   * (source: https://forum.arduino.cc/index.php?topic=111868.msg840693#msg840693)
   * 
   * Conclusion: randomSeed sucks. Let's use the Entropy library instead.
   */
  Entropy.initialize();

  /* Restore the values previously saved in the EEPROM, unless they are invalid */
  uint16_t d;
  EEPROM_readAnything(DURATION_ADDR, d);
  if (d >= MIN_BOUNCES_DURATION && d <= MAX_BOUNCES_DURATION) bouncesDuration = d;
  uint8_t b;
  EEPROM_readAnything(BOUNCES_ADDR, b);
  if (b >= MIN_NB_BOUNCES && b <= MAX_NB_BOUNCES) nbBounces = b;
}

void showInputMenu() {
  /* When lcd.printf() encounters '\n' it clears the rest of the line, so
   * calling lcd.cls() (which is pretty slow) would be a waste of resources.
   */
  lcd.print(0, "[1,4]D[2,999]\n");
  lcd.print(1, "Roll ?D?:\n");
  caretOffset = 0;
}

void rollDice() {
  if (nbDice < 1 || nbSides < 2) {
    lcd.printf(0, "D%-3d ERROR!\n", nbSides);
    lcd.printf(1, "...  # dice: %d\n", nbDice);
    return;
  }
  if (nbDice == 1) {
    lcd.printf(0, "D%-3d 1)%-3d\n", nbSides, rollDie());
    lcd.printf(1, "...\n");
  } else {
    lcd.printf(0, "D%-3d 1)%-3d 2)%-3d\n", nbSides, rollDie(), rollDie());
    switch (nbDice) {
    case 2:
      lcd.printf(1, "...\n");
      break;
    case 3:
      lcd.printf(1, "...  3)%-3d\n", rollDie());
      break;
    case 4:
      lcd.printf(1, "...  3)%-3d 4)%-3d\n", rollDie(), rollDie());
      break;
    }
  }
}

uint16_t rollDie() {
  return Entropy.random(1, nbSides + 1); // return a value in [1,nbSides]
}

void loop() {
  char key = customKeypad.getKey();
  switch (key) {
  default:
    uint8_t i;
    if (key >= '1' && key <= '9') {
      i = key - '1'; // convert '1' to 0, '2' to 1, etc.
      ringTones(i % 3, i / 3);
      typeChar(key);
    } else {
      if (key == '0') {
        ringTones(1, 3);
        typeChar(key);
      } else { // keys 'A', 'B', 'C', 'D'
        i = key - 'A'; // convert 'A' to 0, 'B' to 1, etc.
        ringTones(3, i);
        resetDie();
        switch (key) {
        case 'A':
          testRandomness();
          break;
        case 'B':
          toggleMute();
          break;
        case 'C':
          changeValue("Bounces duration", MIN_BOUNCES_DURATION, MAX_BOUNCES_DURATION, DURATION_ADDR, bouncesDuration);
          break;
        case 'D':
          changeValue("No. of bounces", MIN_NB_BOUNCES, MAX_NB_BOUNCES, BOUNCES_ADDR, nbBounces);
          break;
        }
      }
    }
    break;
  case '*':
    ringTones(0, 3);
    deleteChar();
    break;
  case '#':
    ringTones(2, 3);
    validate();
    break;
  case NULL: // cycles when the user is not typing
    if (caretOffset < 5) { // if more input is allowed
      lcd.putcxy(millis() / 500 % 2 ? '_' : ' ', INPUT_POS + caretOffset, 1); // show blinking caret
    }
    break;
  }
}

void typeChar(const char key) {
  if (caretOffset < 5) { // if more input is allowed
    lcd.putcxy(key, INPUT_POS + caretOffset, 1);
    uint8_t digit = key - '0'; // convert an ASCII character into the integer value it represents
    if (caretOffset == 0) { // if this is the first character
      if (key >= '1' && key <= '4') { // if the character is valid
        nbDice = digit;
        nbSidesInputLen = 0;
        lcd.putcxy(key, INPUT_POS + caretOffset++, 1);
        lcd.putcxy('D', INPUT_POS + caretOffset++, 1);
      }
    } else { // subsequent characters
      if (key >= '0' && key <= '9') { // if the character is valid
        nbSidesInput[nbSidesInputLen++] = digit;
        lcd.putcxy(key, INPUT_POS + caretOffset++, 1);
      }
    }
  }
}

void deleteChar() {
  if (caretOffset > 0) { // if there is something to delete
    lcd.putcxy(' ', INPUT_POS + caretOffset--, 1);
    nbSidesInputLen--;
    if (caretOffset == 1) {
      lcd.putcxy(' ', INPUT_POS + caretOffset--, 1); // erase the 'D'
      nbSidesInputLen = 0;
    }
  }
}

void validate() {
  nbSides = 0;
  for (int i = nbSidesInputLen - 1, n = 1; i != -1 ; --i, n *= 10) {
    nbSides += nbSidesInput[i] * n;
  }
  if (nbSides > 1 && nbDice > 0) {
    for (uint8_t b = 0; b < nbBounces; ++b) {
      // some delay is needed for the LCD to refresh
      delay(bouncesDuration / (1 << nbBounces - b));
      rollDice();
      ringTone(1000, 50);
    }
    lcd.printxy("DONE", 0, 1);
    ringTone(1000, 50);
    while (customKeypad.getKey() == NULL);
    showInputMenu();
  }
}

void resetDie() {
  nbDice = 0;
  nbSidesInputLen = 0;
}

void ringTones(const uint8_t HI_FREQ_INDEX, const uint8_t LO_FREQ_INDEX) {
  #ifdef SOUND
  if (!muted) {
    dualTone[0].play(COL_FREQS[HI_FREQ_INDEX], BEEP_MILLIS);
    dualTone[1].play(ROW_FREQS[LO_FREQ_INDEX], BEEP_MILLIS);
  }
  #endif
}

void ringTone(const uint16_t tone, const uint16_t millis) {
  #ifdef SOUND
  if (!muted) {
    dualTone[0].play(tone, millis);
  }
  #endif
}

void testRandomness() {
  for (uint8_t s = 0; s < NB_SIDES_TEST; ++s) {
    count[s] = 0;
  }
  char key = NULL;
  lcd.print(1, "Hit \"A\" to stop\n");
  for (uint16_t i = 0; i < NB_RUNS_TEST && key != 'A'; ++i) {
    key = customKeypad.getKey();
    uint16_t percentageTimesOneHundred = i / float(NB_RUNS_TEST) * 10000;
    uint8_t beforeDecimalPoint = percentageTimesOneHundred / 100;
    // this rump (AVR version) printf function has no floating point format, so we emulate it
    lcd.printf(0, "%dD%d: %3d.%02d%%\n", NB_RUNS_TEST, NB_SIDES_TEST,
      beforeDecimalPoint, percentageTimesOneHundred - beforeDecimalPoint * 100);
    uint8_t randomValue = Entropy.random(1, NB_SIDES_TEST + 1); // randomValue is in [1,NB_SIDES_TEST]
    count[--randomValue]++;
  }
  if (key == 'A') {
    lcd.print(1, "ABORTED!\n");
    while (customKeypad.getKey() == NULL);
    showInputMenu();
  } else {
    lcd.printf(0, "%dD%d: 100.00%%\n", NB_RUNS_TEST, NB_SIDES_TEST);
    lcd.print(1, "DONE\n");
    while (customKeypad.getKey() == NULL);
    lcd.printf(1, "Expected: %d\n", NB_RUNS_TEST / NB_SIDES_TEST);
    for (uint8_t s = 0; key != 'A'; ++s) {
      if (s == NB_SIDES_TEST) s = 0;
      lcd.printf(0, "# of %ds: %d\n", s + 1, count[s]);
      key = NULL;
      while (key == NULL) {
        key = customKeypad.getKey();
      }
    }
    showInputMenu();
  }
}

void toggleMute() {
  lcd.print(0, muted ? "NOW UNMUTED\n" : "NOW MUTED\n");
  lcd.print(1, "\n");
  muted = !muted;
  while (customKeypad.getKey() == NULL);
  showInputMenu();
}

template <class T> void changeValue(const char* text, const uint16_t minValue, const uint16_t maxValue, const int EEPROM_ADDR, T& value) {
  lcd.printf(0, "%s\n", text);
  lcd.printf(1, "[%d,%d]: %d\n", minValue, maxValue, value);
  const uint8_t inputPos = 5 + log10(minValue) + 1 + log10(maxValue) + 1;
  uint8_t input[4];
  uint8_t inputLen = log10(value) + 1;
  T temp = value;
  for (int8_t i = inputLen - 1; i != -1; temp /= 10) input[i--] = temp % 10;
  T newValue = value;
  uint8_t key = NULL;
  while (key != '#' || newValue < minValue || newValue > maxValue) {
    if (key >= '0' && key <= '9' && inputLen < 4) {
      lcd.putcxy(key, inputPos + inputLen, 1);
      input[inputLen++] = key - '0';
    } else {
      if (key == '*' && inputLen > 0) {
        lcd.putcxy(' ', inputPos + inputLen--, 1);
      }
    }
    if (inputLen < 4) {
      lcd.putcxy(millis() / 500 % 2 ? '_' : ' ', inputPos + inputLen, 1); // show blinking caret
    }
    key = customKeypad.getKey();
    if (key == '#') {
      newValue = 0;
      uint16_t n = 1;
      for (int8_t i = inputLen - 1; i != -1; n *= 10) {
        newValue += input[i--] * n;
      }
    }
  }
  value = newValue;
  EEPROM_writeAnything(EEPROM_ADDR, value);
  showInputMenu();
}
